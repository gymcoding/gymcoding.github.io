(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{476:function(r,t,e){"use strict";e.r(t);var o=e(7),a=Object(o.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"들어가며"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#들어가며"}},[r._v("#")]),r._v(" 들어가며")]),r._v(" "),e("p",[r._v("카프카의 모델인 Pub-Sub모델을 알아보고 topic, partition, broker 등 구성요소에 대해서 자세히 알아보자")]),r._v(" "),e("h2",{attrs:{id:"pub-sub-모델"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pub-sub-모델"}},[r._v("#")]),r._v(" Pub-Sub 모델")]),r._v(" "),e("p",[r._v("카프카는 Pub-Sub(발행-구독)모델을 사용하고 있다. 카프카 구성요소를 살펴보기전에 Pub-Sub모델에 대해 먼저 살펴보도록 하자."),e("br"),r._v("\nPub-Sub모델은 Publish/Subscribe의 줄임말로 메시지 기반의 미들웨어 시스템을 말한다. 일반적으로 메시지를 전송할 때는 Publisher가 보내며, 받을 때는 Subscriber가 받는다."),e("br"),r._v("\nPub-Sub은 메시지를 특정 수신자에게 보낼때 직접 보내지 않고 중계자(Broker)를 통해서 메시지를 보낸다.\n"),e("img",{attrs:{src:"/assets/img/pub-sub.png",alt:"이미지"}}),e("a",{attrs:{href:"https://aws.amazon.com/ko/pub-sub-messaging/",target:"_blank",rel:"noopener noreferrer"}},[r._v("AWS Pub-Sub Messaging"),e("OutboundLink")],1)]),r._v(" "),e("p",[r._v("Publisher는 메시지를 Topic을 통해서 카테고리화 한다. 분류된 메시지를 받기를 원하는 Subscriber는 해당 Topic을 구독(Subscribe)함으로써 메시지를 읽어 올 수 있다. 즉, Publisher는 Topic에 대한 정보만 알고 있고, 마찬가지로 Subscriber도 Topic만 바라본다. Publisher와 Subscriber는 서로 모르는 상태로 느슨한 결합("),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Loose_coupling",target:"_blank",rel:"noopener noreferrer"}},[r._v("loose coupling"),e("OutboundLink")],1),r._v(") 구조를 취하고 있다.")]),r._v(" "),e("h2",{attrs:{id:"카프카의-구성요소"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#카프카의-구성요소"}},[r._v("#")]),r._v(" 카프카의 구성요소")]),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#topic-partition-offset"}},[r._v("Topic, Partition, Offset")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#producer-consumer-consumer-group"}},[r._v("Producer, Consumer, Consumer group")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#broker-zookeeper"}},[r._v("Broker, Zookeeper")])]),r._v(" "),e("li",[e("a",{attrs:{href:"#replication"}},[r._v("Replication")])])]),r._v(" "),e("h3",{attrs:{id:"topic-partition-offset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topic-partition-offset"}},[r._v("#")]),r._v(" Topic, Partition, Offset")]),r._v(" "),e("p",[r._v("카프카에 저장된 메시지는 Topic으로 분류되고, Topic은 여러개의 Partition으로 나뉘어 저장될 수 있다. Partition안에는 메시지의 상대적 위치를 나타내는 Offset이 있는데 이 Offset정보를 이용해 이전에 가져간 메시지의 위치 정보를 알 수 있다.\n"),e("img",{attrs:{src:"/assets/img/kafka-topic-partition.png",alt:"이미지"}})]),r._v(" "),e("h5",{attrs:{id:"여러개의-partition으로-나누어-저장하는-이유는-무엇일까"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#여러개의-partition으로-나누어-저장하는-이유는-무엇일까"}},[r._v("#")]),r._v(" 여러개의 Partition으로 나누어 저장하는 이유는 무엇일까?")]),r._v(" "),e("ul",[e("li",[r._v("여러개의 Partition에 나누어 저장하기 때문에 병렬로 "),e("strong",[r._v("빠르게 메시지를 처리")]),r._v("할 수 있다.")])]),r._v(" "),e("h5",{attrs:{id:"운영중에-partition-개수를-늘릴-수-있을까"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#운영중에-partition-개수를-늘릴-수-있을까"}},[r._v("#")]),r._v(" 운영중에 Partition 개수를 늘릴 수 있을까?")]),r._v(" "),e("ul",[e("li",[r._v("Partition 개수를 운영중 늘릴 수 있다. 그러나!! "),e("strong",[r._v("한번 늘린 파티션은 다시 줄일 수 없으므로(주의)")]),r._v(", 파티션을 늘릴때는 충분히 고민해 봐야 한다.")])]),r._v(" "),e("h5",{attrs:{id:"partition-데이터-처리-순서는"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partition-데이터-처리-순서는"}},[r._v("#")]),r._v(" Partition 데이터 처리 순서는?")]),r._v(" "),e("ul",[e("li",[r._v("메시지 처리순서는 파티션 별로 유지 관리됨. (파티션이 여러개일 경우 메시지 처리순서를 보장할 수 없다.)")])]),r._v(" "),e("h3",{attrs:{id:"producer-consumer-consumer-group"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#producer-consumer-consumer-group"}},[r._v("#")]),r._v(" Producer, Consumer, Consumer Group")]),r._v(" "),e("h5",{attrs:{id:"producer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#producer"}},[r._v("#")]),r._v(" Producer")]),r._v(" "),e("p",[r._v("Producer는 메시지를 생산(Write)하는 주체이며, 메시지를 만들고 Topic에 메시지를 쓴다. Producer는 Consumer의 존재를 알지 못하며 그냥 카프카에 메시지를 쓴다.")]),r._v(" "),e("h5",{attrs:{id:"consumer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[r._v("#")]),r._v(" Consumer")]),r._v(" "),e("p",[r._v("Consumer는 메시지를 소비(Read)하는 주체이다. 필요한 Topic을 카프카에서 구독함으로써 메시지를 소비한다. Consumer는 해당 Topic의 소비한 Offset위치를 기억하고 관리함으로써 어디까지 Topic메시지를 소비했는지 기억할 수 있다. 그렇기 때문에 Consumer가 다운됐을 경우 마지막으로 읽었던 위치에서 부터 다시 읽어들일 수 있다. 즉 fail-over에 대한 신뢰가 존재한다.")]),r._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/producer-consumer.png",alt:"이미지"}})]),r._v(" "),e("h5",{attrs:{id:"consumer-group"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#consumer-group"}},[r._v("#")]),r._v(" Consumer Group")]),r._v(" "),e("p",[r._v("카프카 Topic - Partition에 나뉘어 저장된 메시지들은 컨슈머(Consumer)에 의해 읽혀진다. 하나 이상의 카프카 컨슈머들은 컨슈머 그룹(Consumer Group)을 형성한다. 컨슈머 그룹은 말그대로 컨슈머들의 묶음이며, 하나의 목표를 위해 소비를 하는 그룹이라고도 할 수 있다. 즉, 하나의 토픽을 읽어가기 위한 컨슈머들을 컨슈머 그룹이라 한다.\n"),e("br"),r._v("\n컨슈머 그룹에는 한가지 룰이 있다. Topic의 Partition은 그 Topic을 소비하고 있는 Consumer Group과 1:N 매칭을 해야 한다. 더 간단히 말하자면 Consumer Group의 Consumer 개수는 해당 Topic의 파티션 개수보다 작거나 같아야 한다.\n"),e("br"),r._v("\n왜냐하면 예를들어 Partition 개수가 3개이고, Consumer Group의 Consumer 개수가 3개 라면, Consumer는 Partition에서 메시지를 소비할 때 1:1 관계를 맺게 되지만, Consumer 개수가 Partition개수보다 더 많을 경우 그 수많큼 Consumer는 대기(할일 없음) 상태가 된다.")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("Partition수와 Consumer수가 동일한 경우 1:1 할당됨\n"),e("img",{attrs:{src:"/assets/img/partition-consumer-3-3.png",alt:"이미지"}})])]),r._v(" "),e("li",[e("p",[r._v("Partition수가 Consumer수보다 많은 경우 1:N 할당됨\n"),e("img",{attrs:{src:"/assets/img/partition-consumer-4-3.png",alt:"이미지"}})])]),r._v(" "),e("li",[e("p",[r._v("Consumer수가 더 많은경우에는 초과 Consumer 수만큼 대기 상태가 됨\n"),e("img",{attrs:{src:"/assets/img/partition-consumer-3-4.png",alt:"이미지"}})])])]),r._v(" "),e("p",[r._v("컨슈머그룹이 존재하는 또 다른 이유가 있다. 물론 이러한 구조로 데이터를 병렬로 읽게 되어 빠른처리가 가능하다는 부분도 있겠지만, 특정 컨슈머에 문제가 생겼을 경우 다른 그룹내 컨슈머가 대신 읽을 수 있게 "),e("strong",[r._v("리벨런싱이 되어 장애 상황에서도 문제 없이 대처")]),r._v("할 수 있게 된다.")]),r._v(" "),e("h3",{attrs:{id:"broker-zookeeper"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#broker-zookeeper"}},[r._v("#")]),r._v(" Broker, Zookeeper")]),r._v(" "),e("p",[r._v("broker는 카프카 서버를 칭한다. Kafka 서버 환경설정 파일인 "),e("code",[r._v("config/server.properties")]),r._v(" 파일내 "),e("code",[r._v("broker.id=1...n")]),r._v("으로 설정 함으로써 동일한 노드내에서 여러개의 broker서버를 띄울 수 있고, 카프카는 Broker의 리소스를 최대한 활용하기 위해 각 Topic들을 균등하기 Broker들에게 분산하도록 설계되어 있다. 만약 Broker들에게 분산되어 있는 파티션의 위치가 마음에 들지 않는다면 관리자가 수동으로 조정할 수 있다.\n"),e("img",{attrs:{src:"/assets/img/brokers.jpeg",alt:"이미지"}})]),r._v(" "),e("p",[r._v("Zookeeper는 이러한 분산 메시지큐의 정보를 관리해주는 역할을 한다. 카프카를 띄우기 위해서는 반드시 주키퍼가 실행되어야 한다.")]),r._v(" "),e("h3",{attrs:{id:"replication"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#replication"}},[r._v("#")]),r._v(" Replication")]),r._v(" "),e("p",[r._v("카프카 Replication이란 메시지의 유실을 방지하기 위해서, 여러개의 Kafka Broker로 메시지를 복제하는 기능을말한다.")]),r._v(" "),e("h5",{attrs:{id:"replication-관련-용어"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#replication-관련-용어"}},[r._v("#")]),r._v(" Replication 관련 용어")]),r._v(" "),e("ul",[e("li",[r._v("Leader&Follower"),e("br"),r._v("\n메시지가 복제되는 경우 원본 메시지는 "),e("strong",[r._v("Leader")]),r._v("라 하고, 복제된 메시지를 "),e("strong",[r._v("Follower")]),r._v("라 한다.")]),r._v(" "),e("li",[r._v("ISP (In-Sync Replication)"),e("br"),r._v("\n메시지 복제가 정상적으로 지연없이 복제되는 경우")]),r._v(" "),e("li",[r._v("OSR(Out of Sync Replication)"),e("br"),r._v("\n원본 메시지보다 너무 늦게 복제되는 경우 카프카에서는 replication 수를 임의로 지정하여 topic를 만들 수 있다. replication-factor에 지정하는데 만약 3으로 하면 replication 수가 3이 된다.")])]),r._v(" "),e("p",[r._v("Topic으로 통하는 모든 데이터는 오직 Leader에서 이루어지고 Follower는 Leader와 Sync를 유지함으로써 Leader가 문제가 생겼을 경우 Follower들 중 하나가 Leader역할을 하게 되는 것이다."),e("br"),r._v("\n복제된 데이터가 Follower들에게 있으니, 메시지의 유실이 없다는 장점이 있지만, 복제를 하기 위한 시간과 네트워크 비용이 들기 때문에 데이터의 중요도에 따라 Ack옵션으로 성능과 데이터의 중요도에 따라 다음과 같이 세부설정이 가능하다.")]),r._v(" "),e("h5",{attrs:{id:"ack-옵션-default-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ack-옵션-default-1"}},[r._v("#")]),r._v(" Ack 옵션(default: 1)")]),r._v(" "),e("ul",[e("li",[r._v("0: 프로듀서는 자신이 보낸 메시지에 대해 카프카로부터 확인을 기다리지 않습니다.")]),r._v(" "),e("li",[r._v("1: 프로듀서는 자신이 보낸 메시지에 대해 카프카의 leader가 메시지를 받았는지 기다립니다. follower들은 확인하지 않습니다. leader가 확인응답을 보내고, follower에게 복제가 되기 전에 leader가 fail되면, 해당 메시지는 손실될 수 있습니다.")]),r._v(" "),e("li",[r._v("-1(또는 all): 프로듀서는 자신이 보낸 메시지에 대해 카프카의 leader와 follower까지 받았는지 기다립니다. 최소 하나의 복제본까지 처리된 것을 확인하므로 메시지가 손실될 확률은 거의 없습니다.")])]),r._v(" "),e("p",[r._v("지금까지 카프카의 구성요소와 동작 매커니즘에 대해 살펴봤다. 카프카를 운영하기에 앞서 기본적인 구성요소나 매커니즘에 대해 충분히 이해를 하면 운영하는데 많은 도움이 될 것이다.")])])}),[],!1,null,null,null);t.default=a.exports}}]);